<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />

    <link rel="stylesheet" href="plugin/highlight/monokai.css" />

    <style>
      p {
        font-size: 0.6em;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>SOLID</h2>
          <!-- <p>Volha Bashlaminava</p> -->
        </section>
        <section>
          <section>
            <h3>Single-Responsibility Principle</h3>
            <p>A class should have one and only one reason to change</p>
          </section>
          <section>
            <p>Bad way</p>
            <pre>
              <code data-line-numbers="">class UserSettings {
  constructor(user) {
    this.user = user;
  }

  changeSettings(settings) {
    if (this.verifyCredentials()) {
      // ...
    }
  }

  verifyCredentials() {
    // ...
  }
}
              </code>
            </pre>
          </section>
          <section>
            <p>Good way</p>
            <pre>
              <code data-line-numbers="1-9|11-22">class UserAuth {
  constructor(user) {
    this.user = user;
  }

  verifyCredentials() {
    // ...
  }
}

class UserSettings {
  constructor(user) {
    this.user = user;
    this.auth = new UserAuth(user);
  }

  changeSettings(settings) {
    if (this.auth.verifyCredentials()) {
      // ...
    }
  }
}
              </code>
            </pre>
          </section>
        </section>
        <section>
          <section>
            <h3>Open-Closed Principle</h3>
            <p>
              Software entities should be
              open for extension, but closed for modification
            </p>
          </section>
          <section>
            <p>Bad way</p>
            <pre>
              <code data-line-numbers="">var iceCreamFlavors=["chocolate","vanilla"];
var iceCreamMaker={
makeIceCream (flavor) {
  if(iceCreamFlavors.indexOf(flavor)>-1){
  console.log("Great success. You now have ice cream.")
  }else{
  console.log("Epic fail. No ice cream for you.")
  }
}
}
export default iceCreamMaker;
              </code>
            </pre>
          </section>
          <section>
            <p>Good way</p>
            <pre>
              <code data-line-numbers="">iceCreamFlavors=["chocolate","vanilla"];
var iceCreamMaker={
 makeIceCream (flavor) {
  if(iceCreamFlavors.indexOf(flavor)>-1){
   console.log("Great success. You now have ice cream.")
  }else{
   console.log("Epic fail. No ice cream for you.")
  }
 }
 addFlavor(flavor){
  iceCreamFlavors.push(flavor);
 }
}
export default iceCreamMaker;
              </code>
            </pre>
          </section>
        </section>
        <section>
          <section>
            <h3>Liskov Substitution Principle</h3>
            <p>
              Let Φ(x) be a property provable about objects x of type T<br>
              Then Φ(y) should be true for objects y of type S where S is a subtype of T
            </p>
          </section>
          <section>
            <p>Bad way</p>
            <pre>
              <code data-line-numbers="1-13|15-26|28-38|40-51">class Rectangle {
  constructor() {
    this.width = 0;
    this.height = 0;
  }

  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  setWidth(width) {
    this.width = width;
    this.height = width;
  }

  setHeight(height) {
    this.width = height;
    this.height = height;
  }
}

function renderLargeRectangles(rectangles) {
  rectangles.forEach((rectangle) => {
    rectangle.setWidth(4);
    rectangle.setHeight(5);
    const area = rectangle.getArea();
    // BAD: Returns 25 for Square. Should be 20.
    rectangle.render(area);
  });
}

const rectangles = [new Rectangle(), new Rectangle(), new Square()];
renderLargeRectangles(rectangles);
              </code>
            </pre>
          </section>
          <section>
            <p>Good way</p>
            <pre>
              <code data-line-numbers="1-9|11-21|23-32|34-42">class Shape {
  setColor(color) {
    // ...
  }

  render(area) {
    // ...
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  getArea() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(length) {
    super();
    this.length = length;
  }

  getArea() {
    return this.length * this.length;
  }
}

function renderLargeShapes(shapes) {
  shapes.forEach((shape) => {
    const area = shape.getArea();
    shape.render(area);
  });
}

const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];
renderLargeShapes(shapes);
              </code>
            </pre>
          </section>
        </section>
        <section>
          <section>
            <h3>Interface Segregation Principle</h3>
            <p>
              A client should not be forced to implement an interface that it
              doesn’t use
            </p>
          </section>
          <section>
            <p>Bad way</p>
            <pre>
              <code data-line-numbers="1-15|17-21">class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.animationModule.setup();
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName('body'),
  animationModule() {}
  // ...
});
              </code>
            </pre>
          </section>
          <section>
            <p>Good way</p>
            <pre>
              <code data-line-numbers="1-22|24-29">class DOMTraverser {
  constructor(settings) {
    this.settings = settings;
    this.options = settings.options;
    this.setup();
  }

  setup() {
    this.rootNode = this.settings.rootNode;
    this.setupOptions();
  }

  setupOptions() {
    if (this.options.animationModule) {
      // ...
    }
  }

  traverse() {
    // ...
  }
}

const $ = new DOMTraverser({
  rootNode: document.getElementsByTagName('body'),
  options: {
    animationModule() {}
  }
});
              </code>
            </pre>
          </section>
        </section>
        <section>
          <section>
            <h3>Dependency Inversion Principle</h3>
            <p>
              High-level modules should not depend on low-level modules<br>
              Both should depend on abstractions<br>
              Abstractions should not depend on details<br>
              Details should depend on abstractions
            </p>
          </section>
          <section>
            <p>Bad way</p>
            <pre>
              <code data-line-numbers="1-9|11-25">class InventoryRequester {
  constructor() {
    this.REQ_METHODS = ['HTTP'];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryTracker {
  constructor(items) {
    this.items = items;
    this.requester = new InventoryRequester();
  }

  requestItems() {
    this.items.forEach((item) => {
      this.requester.requestItem(item);
    });
  }
}

const inventoryTracker = new InventoryTracker(['apples', 'bananas']);
inventoryTracker.requestItems();
              </code>
            </pre>
          </section>
          <section>
            <p>Good way</p>
            <pre>
              <code data-line-numbers="1-12|14-22|24-35">class InventoryTracker {
  constructor(items, requester) {
    this.items = items;
    this.requester = requester;
  }

  requestItems() {
    this.items.forEach((item) => {
      this.requester.requestItem(item);
    });
  }
}

class InventoryRequesterV1 {
  constructor() {
    this.REQ_METHODS = ['HTTP'];
  }

  requestItem(item) {
    // ...
  }
}

class InventoryRequesterV2 {
  constructor() {
    this.REQ_METHODS = ['WS'];
  }

  requestItem(item) {
    // ...
  }
}

const inventoryTracker = new InventoryTracker(['apples', 'bananas'], new InventoryRequesterV2());
inventoryTracker.requestItems();
              </code>
            </pre>
          </section>
        </section>
        <section>
          <h2>SOLID</h2>
          <p>is something really worth using)</p>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
